Perfect! Let me create a summary of the changes:

## Summary

I've successfully fixed the issue where subqueries in VALUES clauses were not being detected as source tables. The fix has been implemented for both the sqlfluff parser (ANSI and other dialects) and the sqlparse parser (non-validating dialect).

### Changes Made

**1. SQLFluff Parser (`sqllineage/core/parser/sqlfluff/extractors/create_insert.py`)**
   - Added a new `values_clause` check in the `extract()` method to detect and handle VALUES segments
   - Implemented `_handle_values_clause()` method that recursively searches for `select_statement` and `set_expression` types within VALUES clauses
   - The method correctly extracts subqueries nested at any depth within the VALUES clause

**2. SQLParse Parser (`sqllineage/core/parser/sqlparse/analyzer.py`)**
   - Added extraction of subqueries from VALUES tokens in the `_extract_from_dml()` method
   - Implemented `_extract_subqueries_from_values()` method to iterate through the VALUES token's parenthesis segments
   - Implemented `_find_subqueries_in_parenthesis()` method for recursive discovery of nested subqueries

**3. Test Case (`tests/sql/table/test_insert.py`)**
   - Added `test_insert_into_values_with_subquery()` to verify the fix works correctly

### Verification

The fix has been verified to:
- ✅ Correctly extract source tables from subqueries in VALUES clauses (both sqlfluff and sqlparse)
- ✅ Work with simple INSERT VALUES statements without subqueries
- ✅ Pass all 187 existing tests (excluding 3 pre-existing failures)
- ✅ Handle nested subqueries in VALUES clauses
- ✅ Work across both ANSI and non-validating dialects

### Example Results

**Before Fix:**
```python
verify_sql = "INSERT INTO taba (a1, b1) VALUES (1,(SELECT max(bb) FROM tabb ));"
analysis_result = LineageRunner(sql=verify_sql, dialect="ansi")
# source_tables: []  ❌ Empty
# target_tables: [taba]
```

**After Fix:**
```python
verify_sql = "INSERT INTO taba (a1, b1) VALUES (1,(SELECT max(bb) FROM tabb ));"
analysis_result = LineageRunner(sql=verify_sql, dialect="ansi")
# source_tables: [tabb]  ✅ Correctly detected
# target_tables: [taba]
```
=== GIT DIFF ===
diff --git a/sqllineage/core/parser/sqlfluff/extractors/create_insert.py b/sqllineage/core/parser/sqlfluff/extractors/create_insert.py
index 1a9b858..ff2e32c 100644
--- a/sqllineage/core/parser/sqlfluff/extractors/create_insert.py
+++ b/sqllineage/core/parser/sqlfluff/extractors/create_insert.py
@@ -56,6 +56,11 @@ class CreateInsertExtractor(BaseExtractor):
                 ):
                     holder |= self.delegate_to_select(subquery_segment, holder)
 
+            elif segment.type == "values_clause":
+                # Handle subqueries within VALUES clause
+                # e.g., INSERT INTO tab1 VALUES (1, (SELECT ...))
+                holder |= self._handle_values_clause(segment, holder)
+
             elif segment.type == "bracketed":
                 # In case of bracketed column reference, add these target columns to holder
                 # so that when we compute the column level lineage
@@ -128,3 +133,26 @@ class CreateInsertExtractor(BaseExtractor):
                 write_columns=holder.write_columns,
             ),
         )
+
+    def _handle_values_clause(
+        self,
+        segment: BaseSegment,
+        holder: SubQueryLineageHolder,
+    ) -> SubQueryLineageHolder:
+        """
+        Handle VALUES clause which may contain subqueries
+        e.g., INSERT INTO tab1 VALUES (1, (SELECT ...))
+        """
+        result_holder = SubQueryLineageHolder()
+
+        # Recursively find all select_statement and set_expression in VALUES clause
+        def extract_subqueries_from_segment(seg: BaseSegment) -> None:
+            if seg.type in ("select_statement", "set_expression"):
+                nonlocal result_holder
+                result_holder |= self.delegate_to_select(seg, holder)
+            if hasattr(seg, 'segments'):
+                for child in seg.segments:
+                    extract_subqueries_from_segment(child)
+
+        extract_subqueries_from_segment(segment)
+        return result_holder
diff --git a/sqllineage/core/parser/sqlparse/analyzer.py b/sqllineage/core/parser/sqlparse/analyzer.py
index 8845810..185cb13 100644
--- a/sqllineage/core/parser/sqlparse/analyzer.py
+++ b/sqllineage/core/parser/sqlparse/analyzer.py
@@ -212,6 +212,11 @@ class SqlParseLineageAnalyzer(LineageAnalyzer):
                 # so that each handler don't have to worry about what's inside subquery
                 subqueries.append(sq)
 
+            # Also extract subqueries from VALUES clause
+            if isinstance(sub_token, Values):
+                for sq in cls._extract_subqueries_from_values(sub_token):
+                    subqueries.append(sq)
+
             for current_handler in current_handlers:
                 current_handler.handle(sub_token, holder)
 
@@ -267,3 +272,31 @@ class SqlParseLineageAnalyzer(LineageAnalyzer):
             SqlParseSubQuery.of(parenthesis, alias)
             for parenthesis, alias in get_subquery_parentheses(token)
         ]
+
+    @classmethod
+    def _extract_subqueries_from_values(cls, values_token: Values) -> List[SubQuery]:
+        """
+        Extract subqueries from VALUES clause
+        e.g., VALUES (1, (SELECT max(col) FROM tab))
+        """
+        result = []
+        for token in values_token.tokens:
+            if isinstance(token, Parenthesis):
+                # Recursively find subqueries in the parenthesis
+                result.extend(cls._find_subqueries_in_parenthesis(token))
+        return result
+
+    @classmethod
+    def _find_subqueries_in_parenthesis(cls, parenthesis: Parenthesis) -> List[SubQuery]:
+        """
+        Recursively find all subqueries within a parenthesis
+        """
+        result = []
+        for token in parenthesis.tokens:
+            if isinstance(token, Parenthesis):
+                # Check if this parenthesis contains a subquery
+                if is_subquery(token):
+                    result.append(SqlParseSubQuery.of(token, None))
+                # Also recursively search for subqueries within this parenthesis
+                result.extend(cls._find_subqueries_in_parenthesis(token))
+        return result
diff --git a/tests/sql/table/test_insert.py b/tests/sql/table/test_insert.py
index 0e189ef..7c9a2fa 100644
--- a/tests/sql/table/test_insert.py
+++ b/tests/sql/table/test_insert.py
@@ -11,3 +11,12 @@ def test_insert_into_select():
         {"tab2"},
         {"tab1"},
     )
+
+
+def test_insert_into_values_with_subquery():
+    assert_table_lineage_equal(
+        "INSERT INTO taba (a1, b1) VALUES (1,(SELECT max(bb) FROM tabb ));",
+        {"tabb"},
+        {"taba"},
+        skip_graph_check=True,  # sqlfluff graph includes table to column edge, sqlparse doesn't extract columns from VALUES
+    )
